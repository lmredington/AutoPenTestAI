# Latest update: 4/16/2024 - 4/17: adding requirements

#  -------------------
# | Is Not Functional |     -- Most likely will error if run - need to incorporate separate code. 
#  -------------------

#  ----------------
# |  Functionality |
#  ----------------
#   Get Network IP addresses (ipconfig/ifconfig)
#   Get Host Details (nmap)
#   Filter Nuclei
#   Read Linpeas

#  -------------------------
# | Completed Functionality |
#  -------------------------
#   linux get network (local) ip and subnet mask

#  ----------------
# | Latest Updates |
#  ----------------
'''
* select OS
* Windows --> OS
'''


import re
import csv
import subprocess
import os
import xml.etree.ElementTree as ET
import json

# SELECT LOCAL OS:
# OS = 0 # LINUX    
OS = 1 # WINDOWS

def print_section(lines, data, index):
    header_found = False
    for line in lines:
        if header_found:
            if data[index+1] in line:
                break
            print(line)
        elif data[index] in line:
            header_found = True
            print(previous_line)
            print(line)
        previous_line = line
    print()

## Run a Command
def run_command(command):
    print("\nRunning ", command)
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()
    return_code = process.returncode
    if return_code == 0:
        # Command was successful
        print("Output:", output.decode())
        print("Command executed successfully\n")
        
    else:
        # Command failed
        print("Error output:", error.decode())
        print(f"Error executing command. Return code: {return_code}")
        
    return return_code, output.decode()

## Get CIDR Notation
def ip_subnet_to_cidr(ip_address, subnet_mask):
    # Convert IP address and subnet mask to binary strings
    ip_binary = ''.join(format(int(x), '08b') for x in ip_address.split('.'))
    subnet_binary = ''.join(format(int(x), '08b') for x in subnet_mask.split('.'))
    
    # Count the number of significant bits in the subnet mask
    cidr_count = sum([1 for bit in subnet_binary if bit == '1'])
    
    # Create the CIDR notation
    cidr_notation = f"{ip_address}/{cidr_count}"
    
    return cidr_notation

## Get Host Per Network
def extract_host_ip(host_data, xml_file):
    # Parse the XML content
    tree = ET.parse(xml_file)
    root = tree.getroot()

    # Iterate over each 'host' element in the XML
    for host in root.findall('.//host'):
        # Extract IPv4 address
        address_elem = host.find("./address[@addrtype='ipv4']")
        ipv4 = address_elem.attrib['addr'] if address_elem is not None else "n\a"
    
        # Extract hostname
        hostname_elem = host.find("./hostnames/hostname")
        hostname = hostname_elem.attrib['name'] if hostname_elem is not None else None
        
    
        # If hostname is not available, extract vendor information
        if not hostname:
            address_mac_elem = host.find("./address[@addrtype='mac']")
            vendor = address_mac_elem.attrib['vendor'] if address_mac_elem is not None else None
            host_data.append((ipv4, vendor))
        else:
            host_data.append((ipv4, hostname))

    return host_data

# ======================================BEGIN MAIN CODE========================================= #

#--------------Init Variables---------------#

network_ip_data = []
network_host_data = []

#---------------Get Network IP addresses------------#

run_command("Python3 get_ips.py")

## Get Host IPs
for ipv4, subnet_mask, cidr in network_ip_data:  
    network_host_scan_file = "logs/"+ipv4+"_host_scan.xml"                              # Set Output file name
    host_discover_command = "nmap -T5 -sn -oX "+network_host_scan_file+" "+cidr     # Set Host Discover Nmap Command
    run_command(host_discover_command)
    network_host_data = extract_host_ip(network_host_data, network_host_scan_file)              # Save data into host_data

#for ipv4, hostname in network_host_data:
 #   print(hostname+"\t"+ipv4+"\n")
    
print(network_host_data)
print("\n")
print(network_ip_data)
    
#----------------------Get Host Details----------------------#

for ipv4, hostname in network_host_data:
    host_scan_file = "logs/"+ipv4+"nmap.xml"
    host_command = "nmap -v -A -oX "+host_scan_file+" "+ipv4

    '''
        * nmap -v -A 192.168.1.116
        * nmap -Pn -O --script vuln -oA nmapscanCVE 192.168.1.71
        * nmap -Pn -O --script vuln -oA nmapscanCVE 192.168.1.24    -- could give tcp/ip fingerprint, ports, state, service
        * nmap -sV --version-trace 192.168.1.71 -- Gave DNS server
        * nmap -Pn --script-trace 192.168.1.10
        * nmap -v -A scanme.nmap.org -- LOTS OF INFO
        * nmap -Pn -iflist
        '''

#----------------------Print Hosts----------------------#

print("Hosts Detected:\n")
for ipv4 in network_ip_data:
    print(ipv4)   
    
#---------------WRITE DATA TO CSV FILE------------#
    
with open('network_info.csv', 'w', newline='') as csvfile:
    fieldnames = ['IPv4 Address', 'Subnet Mask', 'CIDR', 'Hostname']    # Setup Field Names of CSV
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    for ipv4, subnet_mask, cidr in network_ip_data:         # For each Network IP
        writer.writerow({'IPv4 Address': ipv4, 
                         'Subnet Mask': subnet_mask, 
                         'CIDR': cidr})                     # Save Network IP data into CSV (IP, Subnet, CIDR)
        print('IPv4 Address: '+ipv4+',  Subnet Mask: '+subnet_mask+',   CIDR: '+cidr+'\n')      # Print data
    for ipv4, hostname in network_host_data:                # For each Host
        writer.writerow({'IPv4 Address': ipv4,
                         'Hostname': hostname})             # Save Hostname and IP
                         
#---------------filter Nuclei------------#
# Open the JSON file for reading
with open('nuclei.json', 'r', encoding='utf-8') as file:
    nuclei_data = json.load(file)

# Filter out the desired elements
nuclei_filtered_data = []
for item in nuclei_data:
    nuclei_filtered_item = {
        "template-id": item["template-id"],
        "info": item.get("info", {}),
        "port": item.get("port")
    }
    nuclei_filtered_data.append(nuclei_filtered_item)

# Save the filtered data to a new JSON file
with open('nuclei_filtered.json', 'w') as file:
    json.dump(nuclei_filtered_data, file, indent=4)
    
#---------------Read Linpeas------------#

RUNNING_COMMAND=0


if RUNNING_COMMAND==1:
    run_command("sudo ./linpeas.sh")

# Open the input file for reading
with open('linpeas-result.txt', 'r', encoding='utf-8') as f:
    content = f.read()

# Find the index of the first occurrence of the phrase
index = content.find("Do you like PEASS")

# If the phrase is found, remove everything before it
if index != -1:
    content = content[index:]

# Replace all occurrences of "" with "^"
content = content.replace("", "^")
content = content.replace("â–„", "")

content = content.replace("^[1;4m", "")

content = content.replace("^[1;31;103m", "")
content = content.replace("^[1;31m", "")
content = content.replace("^[1;32m", "")
content = content.replace("^[1;33m", "")
content = content.replace("^[1;34m", "")
content = content.replace("^[1;37m", "")

content = content.replace("^[1;90m", "")
content = content.replace("^[1;95m", "")
content = content.replace("^[1;96m", "")

content = content.replace("^[0m", "")

lines = content.split("\n")

section = ""

# Initialize the list to hold header data
header_data = []
section_data = []
header_subsection_data = []

# Print the rest of each line until it hits "â• " or the end of the line
lines = content.split("\n")
for line in lines:
    index = line.find("â•£")
    if index != -1:
        rest_of_line = line[index+1:]
        end_index = rest_of_line.find("â• ")
        if end_index != -1:
            header = rest_of_line[:end_index].strip()
            header_data.append(header)
            section_data.append(header)
            #print(header)
        else:
            header = rest_of_line.strip()
            section_data.append(header)
            #print(header)
            

            
for i in range(len(header_data)):
    print("["+str(i)+"] "+header_data[i])

header_index = int(input("Enter the integer representing the header: ")) 

print()

section_header_found = False

for section in section_data:
    if section_header_found:
        if section in header_data:
            break
        print("["+str(section_data.index(section))+"] "+section)
        #header_subsection_data.append(section)
    elif section == header_data[header_index]:
        section_header_found = True
        print("["+str(section_data.index(section))+"] "+section)
        #header_subsection_data.append(section)

section_index = int(input("Enter the integer representing the section: ")) 

print()

lines = content.split("\n")
if section_data[section_index] in header_data:
    print_section(lines, header_data, header_index)
else:
    print_section(lines, section_data, section_index)

    
# Write the modified content back to the file
with open('linpeas-filtered.txt', 'w', encoding='utf-8') as f:
    f.write(content)
